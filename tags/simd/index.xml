<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SIMD on Defios Lab.</title>
    <link>https://DefiosLab.github.io/tags/simd/</link>
    <description>Recent content in SIMD on Defios Lab.</description>
    <generator>Hugo</generator>
    <language>jp</language>
    <lastBuildDate>Sat, 24 Dec 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://DefiosLab.github.io/tags/simd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Universal IntrinsicsでSIMDプログラミング</title>
      <link>https://DefiosLab.github.io/post/cv-universal-intrinsic/</link>
      <pubDate>Sat, 24 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://DefiosLab.github.io/post/cv-universal-intrinsic/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://qiita.com/advent-calendar/2022/ipu&#34;&gt;岩手県立大学アドベントカレンダー18日目&lt;/a&gt;の記事です（大遅刻）&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;div class=&#34;iframely-embed&#34;&gt;&lt;div class=&#34;iframely-responsive&#34; style=&#34;height: 140px; padding-bottom: 0;&#34;&gt;&lt;a href=&#34;https://qiita.com/advent-calendar/2022/ipu&#34; data-iframely-url=&#34;//iframely.net/ImHYOMe?card=small&#34;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;script async src=&#34;//iframely.net/embed.js&#34;&gt;&lt;/script&gt;&#xA;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;自己紹介&#34;&gt;自己紹介&lt;/h1&gt;&#xA;&lt;p&gt;はじめまして近藤鯛貴です。&lt;/p&gt;&#xA;&lt;p&gt;岩手県立大学ソフトウェア情報学研究科の博士課程に在学しつつ、Defios株式会社というベンチャー企業を経営しています。&lt;/p&gt;&#xA;&lt;p&gt;大学ではラズパイとかJetsonなどの小型コンピュータを対象に高速化の研究を行っており、会社ではAI/IoT分野を中心に受託開発やコンサルティング業務を行ってます。&lt;/p&gt;&#xA;&lt;p&gt;最近Defiosで技術ブログを立ち上げました。せっかくなのでこちらから投稿します。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;1はじめに&#34;&gt;1．はじめに&lt;/h1&gt;&#xA;&lt;p&gt;現代の大体のCPUではSIMD（Single Instruction Multiple Data)命令が実行可能です。SIMDとは一つの命令で複数のデータを処理する並列化形態です。上手く使うことでソフトウェアを高速化することが出来ます。&lt;br&gt;&#xA;しかし、プロセッサのアーキテクチャや製品種類によって対応しているSIMDのbit幅や命令セットが異なり、様々なコンピュータ上でSIMDを活用するアプリケーションを実装するのは少し厄介です。&lt;/p&gt;&#xA;&lt;p&gt;ふと、画像処理ライブラリであるOpenCVのSIMD対応がどうなっているのか気になって調べたところ以下の記事を見つけました。&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;div class=&#34;iframely-embed&#34;&gt;&lt;div class=&#34;iframely-responsive&#34; style=&#34;height: 140px; padding-bottom: 0;&#34;&gt;&lt;a href=&#34;https://qiita.com/tomoaki_teshima/items/8195c25a3f0448ce300b&#34; data-iframely-url=&#34;//iframely.net/qt3Wvjm?card=small&#34;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;script async src=&#34;//iframely.net/embed.js&#34;&gt;&lt;/script&gt;&#xA;&lt;div class=&#34;iframely-embed&#34;&gt;&lt;div class=&#34;iframely-responsive&#34; style=&#34;height: 140px; padding-bottom: 0;&#34;&gt;&lt;a href=&#34;https://qiita.com/hon_no_mushi/items/df9b8159e7fb47c9e30c&#34; data-iframely-url=&#34;//iframely.net/TLsWpHM?card=small&#34;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;script async src=&#34;//iframely.net/embed.js&#34;&gt;&lt;/script&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;どうやら、OpenCVでは&lt;strong&gt;Universal Intrinsic&lt;/strong&gt;というライブラリを用いてSIMDアーキテクチャの差異を吸収しているようです。&lt;/p&gt;&#xA;&lt;p&gt;本記事ではこのUniversal Intrinsic(以下UI)の使い方と簡単な実装例を紹介します。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;2使い方&#34;&gt;2．使い方&lt;/h1&gt;&#xA;&lt;p&gt;普通にOpenCVをインストールして、&lt;code&gt;&amp;lt;opencv2/core/simd_intrinsics.hpp&amp;gt;&lt;/code&gt;をincludeすればUIを使うことが出来ます。&lt;br&gt;&#xA;SIMDが有効になっているか、どのbit幅が使えるかはOpenCVのサンプルの&lt;a href=&#34;https://github.com/opencv/opencv/blob/4.x/samples/cpp/simd_basic.cpp&#34;&gt;simd_basic.cpp&lt;/a&gt;を実行することで確認できます。&lt;br&gt;&#xA;以下AVX2環境でのsimd_basic.cppの実行結果&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#xA;==================  macro dump  ===================&#xA;CV_SIMD is defined: 1&#xA;CV_SIMD_WIDTH is defined: 32&#xA;CV_SIMD128 is defined: 1&#xA;CV_SIMD256 is defined: 1&#xA;CV_SIMD512 is defined: 0&#xA;CV_SIMD_64F is defined: 1&#xA;CV_SIMD_FP16 is defined: 0&#xA;=================  sizeof checks  =================&#xA;sizeof(v_uint8) = 32&#xA;sizeof(v_int32) = 32&#xA;sizeof(v_float32) = 32&#xA;==================  arithm check  =================&#xA;(vx_setall_u8(10) + vx_setall_u8(45)).get0() =&amp;gt; 55&#xA;=====================  done  ======================&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AVX2のSIMD幅は256bitです。&lt;code&gt;CV_SIMD256&lt;/code&gt;が1となっているので有効になっていることが分かります。&lt;br&gt;&#xA;ちなみに、私の環境ではコンパイルする際に-mavx2(gcc)オプションを入れないとAVX2が有効にならずにSSEで実行されました。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
